{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to VHDL Development This website is for those learning or working with VHDL. The focus is on learning by application. Instead of examining the syntax of VHDL, this site is more concerned with what we can make using VHDL. There are other resources or textbooks that already do an excellent job teaching VHDL as a language, but there are few resources available that demonstrate how it can be used. There is little attention paid to any building blocks that are left by the wayside as soon as we start developing digital circuits for real. You won't find any explanation of Karnaugh maps here because I've already long forgotten how to use them. I hope to teach VHDL by providing clear demonstrations of how it can be used, with well written examples of fundamental building blocks that are required for a wide variety of designs. After grasping the basics by reading and testing examples of real designs, I will take a more in-depth look at actually designing for real hardware and the challenges that can be encountered on FPGAs. For those readers that already have a firm grasp of VHDL, I hope I can provide ready to use building blocks that can be used in your designs as a block box, leaving you with more time to focus on coding application specific modules. Learning VHDL By Application","title":"Home"},{"location":"index.html#welcome-to-vhdl-development","text":"This website is for those learning or working with VHDL. The focus is on learning by application. Instead of examining the syntax of VHDL, this site is more concerned with what we can make using VHDL. There are other resources or textbooks that already do an excellent job teaching VHDL as a language, but there are few resources available that demonstrate how it can be used. There is little attention paid to any building blocks that are left by the wayside as soon as we start developing digital circuits for real. You won't find any explanation of Karnaugh maps here because I've already long forgotten how to use them. I hope to teach VHDL by providing clear demonstrations of how it can be used, with well written examples of fundamental building blocks that are required for a wide variety of designs. After grasping the basics by reading and testing examples of real designs, I will take a more in-depth look at actually designing for real hardware and the challenges that can be encountered on FPGAs. For those readers that already have a firm grasp of VHDL, I hope I can provide ready to use building blocks that can be used in your designs as a block box, leaving you with more time to focus on coding application specific modules. Learning VHDL By Application","title":"Welcome to VHDL Development"},{"location":"Demo.html","text":"This is normal text. Note This is how to create a note. Text must be indented by 4 spaces. Tip This is a tip box. Text must be indented by 4 spaces. This is a blockquote This is the second line of the blockquote This is the second paragraph of the blockquote This is a nested blockquote.","title":"Demo Markdown"},{"location":"about.html","text":"About","title":"About"},{"location":"about.html#about","text":"","title":"About"},{"location":"VHDL/VHDL%20By%20Application.html","text":"VHDL By Application In this section, VHDL building blocks are introduced in order of building complexity. This gradual introduction of complexity is designed to give a new VHDL developer confidence as they build up an general feeling for VHDL as a hardware description language and as a tool for building digital designs. We'll be examining these modules not such as code but also reviewing the digital circuitry the code creates. This is the biggest stumbling block when learning VHDL, don't let yourself forget that you are describing hardware, not just writing code. Everything you write must be synthesisable (unless writing the simulation testbench of course). All modules are available for download and have accompanying simulation testbenches. It's a good idea to download these modules examine the code and the simulated output in greater detail to further your understanding. VHDL Modules Combinatorial Blocks Multiplexer Tri-State Buffer Clocked Components and Registers D-Type Flip Flop Counter State Machine State Machine Memory Single Port Memory Dual Port Memory Clock and Reset Management Clock Buffer Transferring Data Across Clock Domains Four Phase Handshaking Protocol Second Phase Handshaking Protocol One Phase Data Transfer To Be Organised Shift Register LFSR (Linear Feedback Shift Register) Arbitary-Sequence Counter Binary Counter Decade Counter Programmable mod-m Counter Gray Counter Ring Counter Decimal Counter One Segment Code Pulse Width Modulation Circuit Pipelines One Shot Pulse Generator SRAM Controller UART Receiver Square Approximation Circuit Binary Decoder Binary Encoder Priority Encoder Barrel Shifter Multiplier","title":"VHDL By Application"},{"location":"VHDL/VHDL%20By%20Application.html#vhdl-by-application","text":"In this section, VHDL building blocks are introduced in order of building complexity. This gradual introduction of complexity is designed to give a new VHDL developer confidence as they build up an general feeling for VHDL as a hardware description language and as a tool for building digital designs. We'll be examining these modules not such as code but also reviewing the digital circuitry the code creates. This is the biggest stumbling block when learning VHDL, don't let yourself forget that you are describing hardware, not just writing code. Everything you write must be synthesisable (unless writing the simulation testbench of course). All modules are available for download and have accompanying simulation testbenches. It's a good idea to download these modules examine the code and the simulated output in greater detail to further your understanding.","title":"VHDL By Application"},{"location":"VHDL/VHDL%20By%20Application.html#vhdl-modules","text":"","title":"VHDL Modules"},{"location":"VHDL/VHDL%20By%20Application.html#combinatorial-blocks","text":"Multiplexer Tri-State Buffer","title":"Combinatorial Blocks"},{"location":"VHDL/VHDL%20By%20Application.html#clocked-components-and-registers","text":"D-Type Flip Flop Counter","title":"Clocked Components and Registers"},{"location":"VHDL/VHDL%20By%20Application.html#state-machine","text":"State Machine","title":"State Machine"},{"location":"VHDL/VHDL%20By%20Application.html#memory","text":"Single Port Memory Dual Port Memory","title":"Memory"},{"location":"VHDL/VHDL%20By%20Application.html#clock-and-reset-management","text":"Clock Buffer","title":"Clock and Reset Management"},{"location":"VHDL/VHDL%20By%20Application.html#transferring-data-across-clock-domains","text":"Four Phase Handshaking Protocol Second Phase Handshaking Protocol One Phase Data Transfer","title":"Transferring Data Across Clock Domains"},{"location":"VHDL/VHDL%20By%20Application.html#to-be-organised","text":"Shift Register LFSR (Linear Feedback Shift Register) Arbitary-Sequence Counter Binary Counter Decade Counter Programmable mod-m Counter Gray Counter Ring Counter Decimal Counter One Segment Code Pulse Width Modulation Circuit Pipelines One Shot Pulse Generator SRAM Controller UART Receiver Square Approximation Circuit Binary Decoder Binary Encoder Priority Encoder Barrel Shifter Multiplier","title":"To Be Organised"},{"location":"VHDL/My%20Notes/My%20Notes.html","text":"My Notes VHDL By Example","title":"My Notes"},{"location":"VHDL/My%20Notes/My%20Notes.html#my-notes","text":"VHDL By Example","title":"My Notes"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/1_Multiplexer.html","text":"1. Multiplexer A multiplexer (or MUX) selects one output from a choice of inputs. Todo Replace with your own image Below I've included VHDL implementing a multiplexer using two different methods. First using a with/select assignment, then using a When/Else assignment. Both these modules will operate identically and how they are implemented is down to personal preference. Multiplexer using With/Select Assignment library ieee ; use ieee.std_logic_1164. all ; entity MULTIPLEXER is port ( INPUT_1 : in std_logic_vector ( 3 downto 0 ); INPUT_2 : in std_logic_vector ( 3 downto 0 ); SELECT : in std_logic ; OUTPUT : out std_logic_vector ( 3 downto 0 ) ); end entity MULTIPLEXER ; architecture RTL of MULTIPLEXER is begin with ( SELECT ) select OUTPUT <= INPUT_1 when '0' , INPUT_2 when '1' , others => '0' when others ; end architecture MULTIPLEXER ; Warning Always include a \"when others\" condition. We must tell our circuit how to behave when it can determine if a signal is a 0 or a 1. In VHDL simulation we also use Z and X states to represent high impedance and unknown states representatively. Multiplexer using When/Else Assignment library ieee ; use ieee.std_logic_1164. all ; entity MULTIPLEXER is port ( INPUT_1 : in std_logic_vector ( 3 downto 0 ); INPUT_2 : in std_logic_vector ( 3 downto 0 ); SELECT : in std_logic ; OUTPUT : out std_logic_vector ( 3 downto 0 ) ); end entity MULTIPLEXER ; architecture RTL of MULTIPLEXER is begin OUTPUT <= INPUT_1 when ( SELECT = '0' ) else INPUT_2 ; end architecture MULTIPLEXER ;","title":"1 Multiplexer"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/1_Multiplexer.html#1-multiplexer","text":"A multiplexer (or MUX) selects one output from a choice of inputs. Todo Replace with your own image Below I've included VHDL implementing a multiplexer using two different methods. First using a with/select assignment, then using a When/Else assignment. Both these modules will operate identically and how they are implemented is down to personal preference.","title":"1. Multiplexer"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/1_Multiplexer.html#multiplexer-using-withselect-assignment","text":"library ieee ; use ieee.std_logic_1164. all ; entity MULTIPLEXER is port ( INPUT_1 : in std_logic_vector ( 3 downto 0 ); INPUT_2 : in std_logic_vector ( 3 downto 0 ); SELECT : in std_logic ; OUTPUT : out std_logic_vector ( 3 downto 0 ) ); end entity MULTIPLEXER ; architecture RTL of MULTIPLEXER is begin with ( SELECT ) select OUTPUT <= INPUT_1 when '0' , INPUT_2 when '1' , others => '0' when others ; end architecture MULTIPLEXER ; Warning Always include a \"when others\" condition. We must tell our circuit how to behave when it can determine if a signal is a 0 or a 1. In VHDL simulation we also use Z and X states to represent high impedance and unknown states representatively.","title":"Multiplexer using With/Select Assignment"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/1_Multiplexer.html#multiplexer-using-whenelse-assignment","text":"library ieee ; use ieee.std_logic_1164. all ; entity MULTIPLEXER is port ( INPUT_1 : in std_logic_vector ( 3 downto 0 ); INPUT_2 : in std_logic_vector ( 3 downto 0 ); SELECT : in std_logic ; OUTPUT : out std_logic_vector ( 3 downto 0 ) ); end entity MULTIPLEXER ; architecture RTL of MULTIPLEXER is begin OUTPUT <= INPUT_1 when ( SELECT = '0' ) else INPUT_2 ; end architecture MULTIPLEXER ;","title":"Multiplexer using When/Else Assignment"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/2_D_Type_Flip_Flop.html","text":"2. Flip Flops and Latches Flip flops are single bit devices with two stable states (0 or 1) that can be used as single bit storage. These come in a few flavours which we'll elaborate on below. Multiple flip flops are typically connected in parallel or in series to form registers and shift-registers (more on these below). Applications include: * Counters * Frequency Dividers * Shift Registers * Storage Registers Latches aren't often used in FPGA and the compiler will often even throw a warning if you've implemented one as these are more common to implement accidentally than deliberately. That said, they can often be useful if used correctly. Todo Link to an example of latches being used effectively. D-Type Flip Flop library ieee ; use ieee.std_logic_1164. all ; entity D_TYPE is port ( CLK : in std_logic ; D : in std_logic ; Q : out std_logic ); end entity D_TYPE ; architecture RTL of D_TYPE is begin REG_PROCESS : process ( CLK ) begin if rising_edge ( CLK ) then Q <= D ; end if ; end process REG_PROCESS ; end architecture RTL ; SR Flip Flop library ieee ; use ieee.std_logic_1164. all ; entity SR_LATCH is port ( CLK : in std_logic ; S : in std_logic ; R : in std_logic ; Q : out std_logic ); end entity D_TYPE ; architecture RTL of D_TYPE is begin REG_PROCESS : process ( CLK ) begin if rising_edge ( CLK ) then if ( R = '0' ) then Q <= '0' ; elsif ( S = '1' ) then Q <= '1' ; end if ; end if ; end process REG_PROCESS ; end architecture RTL ; Todo Dangers of latches. Compile provides warning. Applications: * Capture short pulsed triggers Register Note Registers are typically used for small scale storage, for example storing control information for a component. Shift-Register","title":"2 D Type Flip Flop"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/2_D_Type_Flip_Flop.html#2-flip-flops-and-latches","text":"Flip flops are single bit devices with two stable states (0 or 1) that can be used as single bit storage. These come in a few flavours which we'll elaborate on below. Multiple flip flops are typically connected in parallel or in series to form registers and shift-registers (more on these below). Applications include: * Counters * Frequency Dividers * Shift Registers * Storage Registers Latches aren't often used in FPGA and the compiler will often even throw a warning if you've implemented one as these are more common to implement accidentally than deliberately. That said, they can often be useful if used correctly. Todo Link to an example of latches being used effectively.","title":"2. Flip Flops and Latches"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/2_D_Type_Flip_Flop.html#d-type-flip-flop","text":"library ieee ; use ieee.std_logic_1164. all ; entity D_TYPE is port ( CLK : in std_logic ; D : in std_logic ; Q : out std_logic ); end entity D_TYPE ; architecture RTL of D_TYPE is begin REG_PROCESS : process ( CLK ) begin if rising_edge ( CLK ) then Q <= D ; end if ; end process REG_PROCESS ; end architecture RTL ;","title":"D-Type Flip Flop"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/2_D_Type_Flip_Flop.html#sr-flip-flop","text":"library ieee ; use ieee.std_logic_1164. all ; entity SR_LATCH is port ( CLK : in std_logic ; S : in std_logic ; R : in std_logic ; Q : out std_logic ); end entity D_TYPE ; architecture RTL of D_TYPE is begin REG_PROCESS : process ( CLK ) begin if rising_edge ( CLK ) then if ( R = '0' ) then Q <= '0' ; elsif ( S = '1' ) then Q <= '1' ; end if ; end if ; end process REG_PROCESS ; end architecture RTL ; Todo Dangers of latches. Compile provides warning. Applications: * Capture short pulsed triggers","title":"SR Flip Flop"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/2_D_Type_Flip_Flop.html#register","text":"Note Registers are typically used for small scale storage, for example storing control information for a component.","title":"Register"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/2_D_Type_Flip_Flop.html#shift-register","text":"","title":"Shift-Register"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/3_SR_FLOP_COUNTER.html","text":"Counter The counter uses a start and stop event. An SR latch is used to capture the start and stop events. This way these triggers can be a single clock pulse long instead of a continuous signal. This is a concept we will use repeatedly in our designs. Todo Add circuit diagram library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity COUNTER is port ( CLK : in std_logic ; RESET : in std_logic ; START : in std_logic ; STOP : in std_logic ; COUNT : out std_logic_vector ( 3 downto 0 ) ); end entity COUNTER ; architecture RTL of COUNTER is -- Internal signals. The _I postfix indicates an internal signal/register signal START_I : std_logic ; signal STOP_I : std_logic ; signal COUNT_I : unsigned ( 3 downto 0 ); begin COUNT : process ( CLK , RESET ) begin if ( RESET = '1' ) then START_I <= '0' ; -- Rename to ENABLE STOP_I <= '0' ; COUNT_I <= '0' ; elsif rising_edge ( CLK ) then -- SR Latch if ( START = '1' ) then START_I <= '1' ; elsif ( STOP = '1' ) then START_I <= '1' ; end if ; if ( START_I = '1' ) then if ( COUNT_I = X\"E\" ) then COUNT_I <= others => '0' ; else COUNT_I <= COUNT_I + 1 ; end if ; end if ; end process REG_PROCESS ; -- Cast our internal count signal to a std_logic_vector from an unsigned -- and assignment to the output of our counter. COUNT <= std_logic_vector ( COUNT_I ); end architecture RTL ; As our COUNT_I is only used within our process, it can be replaced with a variable. The advantage of using a variable here is that they use less memory to simulate than a signal. This is only becomes significant on large designs and will be not see any difference in a small design like this, but it is an ideal time to become familiar with the differences. The key difference between variables and signals is that variables take on their assignments immediately instead of waiting until the next clock edge. When used in this instance, this will change the behaviour of our circuit. Due to the immediate assignment, our internal counter will double count following a reset so our code must be rewritten to prevent this (see below). Using Variables library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity COUNTER_VAR is port ( CLK : in std_logic ; RESET : in std_logic ; START : in std_logic ; STOP : in std_logic ; COUNT : out std_logic_vector ( 3 downto 0 ) ); end entity COUNTER_VAR ; architecture RTL of COUNTER_VAR is -- Internal signals. The _I postfix indicates an internal signal/register signal START_I : std_logic ; signal STOP_I : std_logic ; begin COUNT : process ( CLK , RESET ) variable START_I : std_logic ; variable STOP_I : std_logic ; variable COUNT_I : unsigned range 0 to 15 ; begin if ( RESET = '1' ) then START_I := '0' ; STOP_I := '0' ; COUNT_I := 0 ; elsif rising_edge ( CLK ) then -- SR Latch if ( START = '1' ) then START_I := '1' ; elsif ( STOP = '1' ) then START_I := '1' ; end if ; if ( START_I = '1' ) then if ( COUNT_I = 15 ) then COUNT_I := 0 ; else COUNT_I := COUNT_I + 1 ; end if ; end if ; end process REG_PROCESS ; -- Cast our internal count signal to a std_logic_vector from an unsigned -- and assignment to the output of our counter. COUNT <= std_logic_vector ( COUNT_I ); end architecture RTL ; Another difference between variables and signals their scope. Variables are local to a process and so can only be used within that process. This does mean that the variable name can be reused, however I don't recommend this unless it is for very simple variable such as loop iterators. The biggest advantage this brings is that someone reading your code knows this variable will only ever be used within this process and not elsewhere in the design. When using a signal as our internal counter, a reader would have to search the rest of the code within the .vhd file to be sure it was not used elsewhere.","title":"3 SR FLOP COUNTER"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/3_SR_FLOP_COUNTER.html#counter","text":"The counter uses a start and stop event. An SR latch is used to capture the start and stop events. This way these triggers can be a single clock pulse long instead of a continuous signal. This is a concept we will use repeatedly in our designs. Todo Add circuit diagram library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity COUNTER is port ( CLK : in std_logic ; RESET : in std_logic ; START : in std_logic ; STOP : in std_logic ; COUNT : out std_logic_vector ( 3 downto 0 ) ); end entity COUNTER ; architecture RTL of COUNTER is -- Internal signals. The _I postfix indicates an internal signal/register signal START_I : std_logic ; signal STOP_I : std_logic ; signal COUNT_I : unsigned ( 3 downto 0 ); begin COUNT : process ( CLK , RESET ) begin if ( RESET = '1' ) then START_I <= '0' ; -- Rename to ENABLE STOP_I <= '0' ; COUNT_I <= '0' ; elsif rising_edge ( CLK ) then -- SR Latch if ( START = '1' ) then START_I <= '1' ; elsif ( STOP = '1' ) then START_I <= '1' ; end if ; if ( START_I = '1' ) then if ( COUNT_I = X\"E\" ) then COUNT_I <= others => '0' ; else COUNT_I <= COUNT_I + 1 ; end if ; end if ; end process REG_PROCESS ; -- Cast our internal count signal to a std_logic_vector from an unsigned -- and assignment to the output of our counter. COUNT <= std_logic_vector ( COUNT_I ); end architecture RTL ; As our COUNT_I is only used within our process, it can be replaced with a variable. The advantage of using a variable here is that they use less memory to simulate than a signal. This is only becomes significant on large designs and will be not see any difference in a small design like this, but it is an ideal time to become familiar with the differences. The key difference between variables and signals is that variables take on their assignments immediately instead of waiting until the next clock edge. When used in this instance, this will change the behaviour of our circuit. Due to the immediate assignment, our internal counter will double count following a reset so our code must be rewritten to prevent this (see below).","title":"Counter"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/3_SR_FLOP_COUNTER.html#using-variables","text":"library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity COUNTER_VAR is port ( CLK : in std_logic ; RESET : in std_logic ; START : in std_logic ; STOP : in std_logic ; COUNT : out std_logic_vector ( 3 downto 0 ) ); end entity COUNTER_VAR ; architecture RTL of COUNTER_VAR is -- Internal signals. The _I postfix indicates an internal signal/register signal START_I : std_logic ; signal STOP_I : std_logic ; begin COUNT : process ( CLK , RESET ) variable START_I : std_logic ; variable STOP_I : std_logic ; variable COUNT_I : unsigned range 0 to 15 ; begin if ( RESET = '1' ) then START_I := '0' ; STOP_I := '0' ; COUNT_I := 0 ; elsif rising_edge ( CLK ) then -- SR Latch if ( START = '1' ) then START_I := '1' ; elsif ( STOP = '1' ) then START_I := '1' ; end if ; if ( START_I = '1' ) then if ( COUNT_I = 15 ) then COUNT_I := 0 ; else COUNT_I := COUNT_I + 1 ; end if ; end if ; end process REG_PROCESS ; -- Cast our internal count signal to a std_logic_vector from an unsigned -- and assignment to the output of our counter. COUNT <= std_logic_vector ( COUNT_I ); end architecture RTL ; Another difference between variables and signals their scope. Variables are local to a process and so can only be used within that process. This does mean that the variable name can be reused, however I don't recommend this unless it is for very simple variable such as loop iterators. The biggest advantage this brings is that someone reading your code knows this variable will only ever be used within this process and not elsewhere in the design. When using a signal as our internal counter, a reader would have to search the rest of the code within the .vhd file to be sure it was not used elsewhere.","title":"Using Variables"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/4_State_Machines.html","text":"4. State Machines Design assumes inputs are synchronized to the FPGA's clock. Otherwise the inputs would need to be clocked through an input register. Some modules will do this as standard procedure if the additional latency will not cause an issue. Todo Recreate the circuit diagram Waits in abort state until the abort signal goes low for improved stability. Complete library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity STATE_MACHINE is port ( CLK : in std_logic ; RESET : in std_logic ; START : in std_logic ; STOP : in std_logic ; COMPLETE : out std_logic ); end entity STATE_MACHINE ; architecture RTL of STATE_MACHINE is type T_STATES is ( IDLE , ACTIVE , FINISH , ABORT ); signal STATE_REG : T_STATES ; signal COUNT : unsigned ( 7 downto 0 ); signal EN : std_logic ; signal CLR : std_logic ; begin STATE_PROC : process ( CLK , RESET ) begin if ( RESET = '1' ) then STATE_REG <= IDLE ; elsif ( rising_edge ( CLK )) then case ( STATE_REG ) is when IDLE => EN <= '0' ; CLR <= '0' ; COMPLETE <= '0' ; if ( START = '1' ) then STATE_REG <= ACTIVE ; end if ; when ACTIVE => EN <= '1' ; CLR <= '0' ; COMPLETE <= '0' ; if ( ABORT = '1' ) then STATE_REG <= ABORT ; elsif ( COUNT = X\"20\" ) then STATE_REG <= FINISH ; end if ; when FINISH => EN <= '0' ; CLR <= '1' ; COMPLETE <= '1' ; STATE_REG <= IDLE ; when ABORT => if ( ABORT = '0' ) then EN <= '0' ; CLR <= '1' ; COMPLETE <= '0' ; STATE_REG <= IDLE ; end if ; when others => end case ; end if ; end process ; COUNT_PROC : process ( CLK , RESET ) begin if ( RESET = '1' ) then COUNT <= ( others => '0' ); elsif ( rising_edge ( CLK )) then if ( CLR = '1' ) then COUNT <= ( others => '0' ); elsif ( EN = '1' ) then COUNT <= COUNT + 1 ; end if ; end if ; end process ; end architecture RTL ;","title":"4. State Machines"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/4_State_Machines.html#4-state-machines","text":"Design assumes inputs are synchronized to the FPGA's clock. Otherwise the inputs would need to be clocked through an input register. Some modules will do this as standard procedure if the additional latency will not cause an issue. Todo Recreate the circuit diagram Waits in abort state until the abort signal goes low for improved stability. Complete library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity STATE_MACHINE is port ( CLK : in std_logic ; RESET : in std_logic ; START : in std_logic ; STOP : in std_logic ; COMPLETE : out std_logic ); end entity STATE_MACHINE ; architecture RTL of STATE_MACHINE is type T_STATES is ( IDLE , ACTIVE , FINISH , ABORT ); signal STATE_REG : T_STATES ; signal COUNT : unsigned ( 7 downto 0 ); signal EN : std_logic ; signal CLR : std_logic ; begin STATE_PROC : process ( CLK , RESET ) begin if ( RESET = '1' ) then STATE_REG <= IDLE ; elsif ( rising_edge ( CLK )) then case ( STATE_REG ) is when IDLE => EN <= '0' ; CLR <= '0' ; COMPLETE <= '0' ; if ( START = '1' ) then STATE_REG <= ACTIVE ; end if ; when ACTIVE => EN <= '1' ; CLR <= '0' ; COMPLETE <= '0' ; if ( ABORT = '1' ) then STATE_REG <= ABORT ; elsif ( COUNT = X\"20\" ) then STATE_REG <= FINISH ; end if ; when FINISH => EN <= '0' ; CLR <= '1' ; COMPLETE <= '1' ; STATE_REG <= IDLE ; when ABORT => if ( ABORT = '0' ) then EN <= '0' ; CLR <= '1' ; COMPLETE <= '0' ; STATE_REG <= IDLE ; end if ; when others => end case ; end if ; end process ; COUNT_PROC : process ( CLK , RESET ) begin if ( RESET = '1' ) then COUNT <= ( others => '0' ); elsif ( rising_edge ( CLK )) then if ( CLR = '1' ) then COUNT <= ( others => '0' ); elsif ( EN = '1' ) then COUNT <= COUNT + 1 ; end if ; end if ; end process ; end architecture RTL ;","title":"4. State Machines"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/5_Memory.html","text":"5. Memory Memory can be defined in three ways: Infer the memory directly via the VHDL code This is the most portable and flexible option but also requires the most design effort and is likely to be the least efficient. We may choose to use this less efficient option if our design is smaller than the smallest available primitive RAM block and save these primitives for where they are really needed. Build the memory using the vendor's primitive RAM structures This will be more efficient than the first option as it will use RAM resources built into the FPGA. It will save design effort too as we will now only need to code the control structures around the primitive. Design the memory using the FPGA vendor's specialised tools (easiest but least portable). This is the easiest option in terms of design effort but does come with a heavily reliance on the vendor. If the design is mitigated to different device in future these IP cores will need to be completely redesigned. This may also be an issue if our code needs to be supported for a long time. Any changes to the vendor's tool may have a direct impact on our design, or worse still the vendor may choose to make this tool obsolete entirely which may force a complete redesign within an existing product. Obviously this may never be an issue, but does come with a rather large headache if it does. Below we implement the same memory structure using option 1 (directly via VHDL code) with two different access methods, single port and dual port. The dual port design has the advantage that read and write access is available simultaneously (or two simultaneous writes). It also provides a method of moving data across clock domains. library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity SINGLE_PORT_RAM is port ( CLK : in std_logic ; DATA_IN : in std_logic_vector ( 15 downto 0 ); WR_ADDR : in std_logic_vector ( 9 downto 0 ); RD_ADDR : in std_logic_vector ( 9 downto 0 ); WR_EN : in std_logic ; DATA_OUT : out std_logic_vector ( 15 downto 0 ) ); end entity SINGLE_PORT_RAM ; architecture RTL of SINGLE_PORT_RAM is type MEMBLK_1Kx16 is array ( 1023 downto 0 ) of std_logic_vector ( 15 downto 0 ); signal RAM : MEMBLK_1Kx16 begin RAM_PROC : process ( CLK ) begin if rising_edge ( CLK ) then if ( WR_EN = '1' ) then RAM ( to_integer ( unsigned ( WR_ADDR )) ) <= DATA_IN ; DATA_OUT <= DATA_IN ; else DATA_OUT <= RAM ( to_integer ( unsigned ( RD_ADDR )) ); end if ; end if ; end process RAM_PROC ; end architecture RTL ; library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity DUAL_PORT_RAM is port ( -- Port A CLK_A : in std_logic ; WR_EN_A : in std_logic ; ADDR_A : in std_logic_vector ( 9 downto 0 ); DATA_IN_A : in std_logic_vector ( 15 downto 0 ); DATA_OUT_A : out std_logic_vector ( 15 downto 0 ); -- Port B CLK_B : in std_logic ; WR_EN_B : in std_logic ; ADDR_B : in std_logic_vector ( 9 downto 0 ); DATA_IN_B : in std_logic_vector ( 15 downto 0 ); DATA_OUT_B : out std_logic_vector ( 15 downto 0 ) ); end entity DUAL_PORT_RAM ; architecture RTL of DUAL_PORT_RAM is type MEMBLK_1Kx16 is array ( 1023 downto 0 ) of std_logic_vector ( 15 downto 0 ); signal RAM : MEMBLK_1Kx16 begin RAM_PROC_A : process ( CLK_A ) begin if rising_edge ( CLK_A ) then if ( WR_EN_A = '1' ) then RAM ( to_integer ( unsigned ( WR_ADDR_A )) ) <= DATA_IN_A ; DATA_OUT_A <= DATA_IN_A ; else DATA_OUT_A <= RAM ( to_integer ( unsigned ( ADDR_A )) ); end if ; end if ; end process RAM_PROC_A ; RAM_PROC_B : process ( CLK_B ) begin if rising_edge ( CLK_B ) then if ( WR_EN_B = '1' ) then RAM ( to_integer ( unsigned ( WR_ADDR_B )) ) <= DATA_IN_B ; DATA_OUT_B <= DATA_IN_B ; else DATA_OUT_B <= RAM ( to_integer ( unsigned ( ADDR_B )) ); end if ; end if ; end process RAM_PROC_B ; end architecture RTL ; In our dual port design, we have no mechanism within VHDL to define the behaviour when the same address is accessed by both ports simultaneously. The behaviour will be determined by the synthesis software or the hardware fabric itself.","title":"5. Memory"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/5_Memory.html#5-memory","text":"Memory can be defined in three ways: Infer the memory directly via the VHDL code This is the most portable and flexible option but also requires the most design effort and is likely to be the least efficient. We may choose to use this less efficient option if our design is smaller than the smallest available primitive RAM block and save these primitives for where they are really needed. Build the memory using the vendor's primitive RAM structures This will be more efficient than the first option as it will use RAM resources built into the FPGA. It will save design effort too as we will now only need to code the control structures around the primitive. Design the memory using the FPGA vendor's specialised tools (easiest but least portable). This is the easiest option in terms of design effort but does come with a heavily reliance on the vendor. If the design is mitigated to different device in future these IP cores will need to be completely redesigned. This may also be an issue if our code needs to be supported for a long time. Any changes to the vendor's tool may have a direct impact on our design, or worse still the vendor may choose to make this tool obsolete entirely which may force a complete redesign within an existing product. Obviously this may never be an issue, but does come with a rather large headache if it does. Below we implement the same memory structure using option 1 (directly via VHDL code) with two different access methods, single port and dual port. The dual port design has the advantage that read and write access is available simultaneously (or two simultaneous writes). It also provides a method of moving data across clock domains. library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity SINGLE_PORT_RAM is port ( CLK : in std_logic ; DATA_IN : in std_logic_vector ( 15 downto 0 ); WR_ADDR : in std_logic_vector ( 9 downto 0 ); RD_ADDR : in std_logic_vector ( 9 downto 0 ); WR_EN : in std_logic ; DATA_OUT : out std_logic_vector ( 15 downto 0 ) ); end entity SINGLE_PORT_RAM ; architecture RTL of SINGLE_PORT_RAM is type MEMBLK_1Kx16 is array ( 1023 downto 0 ) of std_logic_vector ( 15 downto 0 ); signal RAM : MEMBLK_1Kx16 begin RAM_PROC : process ( CLK ) begin if rising_edge ( CLK ) then if ( WR_EN = '1' ) then RAM ( to_integer ( unsigned ( WR_ADDR )) ) <= DATA_IN ; DATA_OUT <= DATA_IN ; else DATA_OUT <= RAM ( to_integer ( unsigned ( RD_ADDR )) ); end if ; end if ; end process RAM_PROC ; end architecture RTL ; library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity DUAL_PORT_RAM is port ( -- Port A CLK_A : in std_logic ; WR_EN_A : in std_logic ; ADDR_A : in std_logic_vector ( 9 downto 0 ); DATA_IN_A : in std_logic_vector ( 15 downto 0 ); DATA_OUT_A : out std_logic_vector ( 15 downto 0 ); -- Port B CLK_B : in std_logic ; WR_EN_B : in std_logic ; ADDR_B : in std_logic_vector ( 9 downto 0 ); DATA_IN_B : in std_logic_vector ( 15 downto 0 ); DATA_OUT_B : out std_logic_vector ( 15 downto 0 ) ); end entity DUAL_PORT_RAM ; architecture RTL of DUAL_PORT_RAM is type MEMBLK_1Kx16 is array ( 1023 downto 0 ) of std_logic_vector ( 15 downto 0 ); signal RAM : MEMBLK_1Kx16 begin RAM_PROC_A : process ( CLK_A ) begin if rising_edge ( CLK_A ) then if ( WR_EN_A = '1' ) then RAM ( to_integer ( unsigned ( WR_ADDR_A )) ) <= DATA_IN_A ; DATA_OUT_A <= DATA_IN_A ; else DATA_OUT_A <= RAM ( to_integer ( unsigned ( ADDR_A )) ); end if ; end if ; end process RAM_PROC_A ; RAM_PROC_B : process ( CLK_B ) begin if rising_edge ( CLK_B ) then if ( WR_EN_B = '1' ) then RAM ( to_integer ( unsigned ( WR_ADDR_B )) ) <= DATA_IN_B ; DATA_OUT_B <= DATA_IN_B ; else DATA_OUT_B <= RAM ( to_integer ( unsigned ( ADDR_B )) ); end if ; end if ; end process RAM_PROC_B ; end architecture RTL ; In our dual port design, we have no mechanism within VHDL to define the behaviour when the same address is accessed by both ports simultaneously. The behaviour will be determined by the synthesis software or the hardware fabric itself.","title":"5. Memory"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/6_Managing_Clocks.html","text":"6. Managing Clocks","title":"6. Managing Clocks"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/6_Managing_Clocks.html#6-managing-clocks","text":"","title":"6. Managing Clocks"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/VHDL%20By%20Example.html","text":"VHDL By Example 1. Multiplexer 2. D-Type Flip Flop 3. SR Flop and Counter 4. State Machines 5. Memory 6. Managing Clocks 10. Delay-Locked Loop (DLL) 11. I/O Flavors","title":"VHDL By Example"},{"location":"VHDL/My%20Notes/VHDL%20By%20Example/VHDL%20By%20Example.html#vhdl-by-example","text":"1. Multiplexer 2. D-Type Flip Flop 3. SR Flop and Counter 4. State Machines 5. Memory 6. Managing Clocks 10. Delay-Locked Loop (DLL) 11. I/O Flavors","title":"VHDL By Example"},{"location":"VHDL/VHDL%20Modules/Coming%20Soon.html","text":"Coming Soon","title":"Coming Soon"},{"location":"VHDL/VHDL%20Modules/Coming%20Soon.html#coming-soon","text":"","title":"Coming Soon"},{"location":"VHDL/VHDL%20Modules/Multiplexer.html","text":"Multiplexer In reality, its unlikely we'd make this an entity in itself in a real design as it can very easily be implemented \"inline\" within another module, but I've included this as a module in its own right because we can learn a useful lesson here. Below there is code showing a multiplexer created \"from scratch\" within a design as well as code instantiating a multiplexer from the entity we have created. The point to takeaway here is that there is an overhead associated with including modules within our design. Dividing our design into submodules to reduce complexity and improve encapsulation and reuse is valuable, but it isn't always worth it. There are no hard and fast rules on when a system should be divided into modules and much of this will come down to your own requirements and preferences. Todo Ideally come up with a rule of thumb here Below I've written all the code required to instantiate and use this module within a design. I've also written how to simply create a multiplexer Todo Examine the code required to instantiate vs the code required to just implicitly make a multiplexer","title":"Multiplexer"},{"location":"VHDL/VHDL%20Modules/Multiplexer.html#multiplexer","text":"In reality, its unlikely we'd make this an entity in itself in a real design as it can very easily be implemented \"inline\" within another module, but I've included this as a module in its own right because we can learn a useful lesson here. Below there is code showing a multiplexer created \"from scratch\" within a design as well as code instantiating a multiplexer from the entity we have created. The point to takeaway here is that there is an overhead associated with including modules within our design. Dividing our design into submodules to reduce complexity and improve encapsulation and reuse is valuable, but it isn't always worth it. There are no hard and fast rules on when a system should be divided into modules and much of this will come down to your own requirements and preferences. Todo Ideally come up with a rule of thumb here Below I've written all the code required to instantiate and use this module within a design. I've also written how to simply create a multiplexer Todo Examine the code required to instantiate vs the code required to just implicitly make a multiplexer","title":"Multiplexer"}]}